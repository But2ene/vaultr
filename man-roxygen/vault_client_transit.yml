custom_mount:
  short: >-
    Set up a \code{vault_client_transit} object at a custom mount.
    For example, suppose you mounted the \code{transit} secret
    backend at \code{/transit2} you might use \code{tr <-
    vault$secrets$transit$custom_mount("/transit2")} - this pattern
    is repeated for other secret and authentication backends.
  params:
    mount: String, indicating the path that the engine is mounted at.

key_create:
  short: >-
    Create a new named encryption key of the specified type. The
    values set here cannot be changed after key creation.
  params:
    name: >-
      Name for the key.  This will be used in all future interactions
      with the key - the key itself is not returned.
    key_type: |-
      Specifies the type of key to create.  The default is
      \code{aes256-gcm96}. The currently-supported types are:

      \describe{

      \item{\code{aes256-gcm96}}{AES-256 wrapped with GCM using a
      96-bit nonce size AEAD (symmetric, supports derivation and
      convergent encryption)}

      \item{\code{chacha20-poly1305}}{ChaCha20-Poly1305 AEAD
      (symmetric, supports derivation and convergent encryption)}

      \item{\code{ed25519}}{ED25519 (asymmetric, supports
      derivation). When using derivation, a sign operation with the
      same context will derive the same key and signature; this is a
      signing analogue to \code{convergent_encryption}}

      \item{\code{ecdsa-p256}}{ECDSA using the P-256 elliptic curve
      (asymmetric)}

      \item{\code{rsa-2048}}{RSA with bit size of 2048 (asymmetric)}

      \item{\code{rsa-4096}}{RSA with bit size of 4096 (asymmetric)}
      }
    convergent_encryption: >-
      Logical with default of \code{FALSE}.  If \code{TRUE}, then the
      key will support convergent encryption, where the same plaintext
      creates the same ciphertext. This requires derived to be set to
      true. When enabled, each encryption(/decryption/rewrap/datakey)
      operation will derive a \code{nonce} value rather than randomly
      generate it.
    derived: >-
      Specifies if key derivation is to be used. If enabled, all
      encrypt/decrypt requests to this named key must provide a
      context which is used for key derivation (default is
      \code{FALSE}).
    exportable: >-
      Enables keys to be exportable. This allows for all the valid
      keys in the key ring to be exported. Once set, this cannot be
      disabled (default is \code{FALSE}).
    allow_plaintext_backup: >-
      If set, enables taking backup of named key in the plaintext
      format. Once set, this cannot be disabled (default is
      \code{FALSE}).

key_read:
  short: >-
    Read information about a previously generated key.  The returned
    object shows the creation time of each key version; the values are
    not the keys themselves. Depending on the type of key, different
    information may be returned, e.g. an asymmetric key will return
    its public key in a standard format for the type.
  params:
    name: The name of the key to read

key_list:
  short: >-
    List names of all keys

key_delete:
  short: >-
    Delete a key by name.  It will no longer be possible to decrypt
    any data encrypted with the named key. Because this is a
    potentially catastrophic operation, the \code{deletion_allowed}
    tunable must be set using \code{$key_update()}.
  params:
    name: The name of the key to delete.

key_update:
  short: >-
    This method allows tuning configuration values for a given
    key. (These values are returned during a read operation on the
    named key.)
  params:
    name: The name of the key to update
    min_decryption_version: >-
      Specifies the minimum version of ciphertext allowed to be
      decrypted, as an integer (default is \code{0}). Adjusting this
      as part of a key rotation policy can prevent old copies of
      ciphertext from being decrypted, should they fall into the wrong
      hands. For signatures, this value controls the minimum version
      of signature that can be verified against. For HMACs, this
      controls the minimum version of a key allowed to be used as the
      key for verification.
    min_encryption_version: >-
      Specifies the minimum version of the key that can be used to
      encrypt plaintext, sign payloads, or generate HMACs, as an
      integer (default is \code{0}).  Must be 0 (which will use the
      latest version) or a value greater or equal to
      \code{min_decryption_version}.
    deletion_allowed: >-
      Specifies if the key is allowed to be deleted, as a logical
      (default is \code{FALSE}).
    exportable: >-
      Enables keys to be exportable. This allows for all the valid
      keys in the key ring to be exported. Once set, this cannot be
      disabled.
    allow_plaintext_backup: >-
      If set, enables taking backup of named key in the plaintext
      format. Once set, this cannot be disabled.

key_rotate:
  short: >-
    Rotates the version of the named key. After rotation, new
    plaintext requests will be encrypted with the new version of the
    key. To upgrade ciphertext to be encrypted with the latest version
    of the key, use the rewrap endpoint. This is only supported with
    keys that support encryption and decryption operations.
  params:
    name: The name of the key to rotate

key_export:
  short: >-
    Export the named key. If version is specified, the specific
    version will be returned. If latest is provided as the version,
    the current key will be provided. Depending on the type of key,
    different information may be returned. The key must be exportable
    to support this operation and the version must still be valid.
  details: >-
    For more details see
    \url{https://github.com/hashicorp/vault/issues/2667} where
    HashiCorp says "Part of the "contract" of transit is that the key
    is never exposed outside of Vault. We added the ability to export
    keys because some enterprises have key escrow requirements, but it
    leaves a permanent mark in the key metadata. I suppose we could at
    some point allow importing a key and also leave such a mark."
  params:
    name: Name of the key to export
    key_type: >-
      Specifies the type of the key to export. Valid values are:
      \code{encryption-key}, \code{signing-key} and \code{hmac-key}.
    version: >-
      Specifies the version of the key to read. If omitted, all
      versions of the key will be returned. If the version is set to
      latest, the current key will be returned

data_encrypt:
  short: >-
    This endpoint encrypts the provided plaintext using the named
    key.
  params:
    key_name: Specifies the name of the encryption key to encrypt against.
    data: Data to encrypt, as a raw vector
    key_version: >-
      Key version to use, as an integer. If not set, uses the latest
      version. Must be greater than or equal to the key's
      \code{min_encryption_version}, if set.
    context: &context >-
      Specifies the context for key derivation. This is required if
      key derivation is enabled for this key.  Must be a raw vector.

data_decrypt:
  short: Decrypts the provided ciphertext using the named key.
  params:
    key_name: Specifies the name of the encryption key to decrypt with.
    data: >-
      The data to decrypt.  Must be a string, as returned by
      \code{$data_encrypt}.
    context: *context

data_rewrap:
  short: >-
    Rewraps the provided ciphertext using the latest version of the
    named key. Because this never returns plaintext, it is possible to
    delegate this functionality to untrusted users or scripts.
  params:
    key_name: Specifies the name of the encryption key to re-encrypt against
    data: >-
      The data to decrypt.  Must be a string, as returned by
      \code{$data_encrypt}.
    context: *context
    key_version: >-
      Specifies the version of the key to use for the operation. If
      not set, uses the latest version. Must be greater than or equal
      to the key's \code{min_encryption_version}, if set.

datakey_create:
  short: >-
    This endpoint generates a new high-entropy key and the value
    encrypted with the named key. Optionally return the plaintext of
    the key as well.
  params:
    name: >-
      Specifies the name of the encryption key to use to encrypt the datakey
    plaintext: >-
      Logical, indicating if the plaintext key should be returned.
    bits: >-
      Specifies the number of bits in the desired key. Can be 128,
      256, or 512.
    context: *context

# NOTE: duplicated with tools
random:
  short: >-
    Generates high-quality random bytes of the specified length.  This
    is totally independent of R's random number stream and provides
    random numbers suitable for cryptographic purposes.
  params:
    bytes: >-
      Number of bytes to generate (as an integer)
    format: >-
      The output format to produce; must be one of \code{hex} (a
      single hex string such as \code{d1189e2f83b72ab6}),
      \code{base64} (a single base64 encoded string such as
      \code{8TDJekY0mYs=}) or \code{raw} (a raw vector of length
      \code{bytes}).

# NOTE: duplicated with tools
hash:
  short: >-
    Generates a cryptographic hash of given data using the specified
    algorithm.
  params:
    data: >-
      A raw vector of data to hash.  To generate a raw vector from an
      R object, one option is to use \code{unserialize(x, NULL)} but
      be aware that version information may be included.
      Alternatively, for a string, one might use \code{charToRaw}.
    algorithm: >-
      A string indicating the hash algorithm to use.  The exact set of
      supported algorithms may depend by vault server version, but as
      of version 1.0.0 vault supports \code{sha2-224},
      \code{sha2-256}, \code{sha2-384} and \code{sha2-512}.  The
      default is \code{sha2-256}.
    format: >-
      The format of the output - must be one of \code{hex} or
      \code{base64}.

hmac:
  short: >-
    This endpoint returns the digest of given data using the specified
    hash algorithm and the named key. The key can be of any type
    supported by the \code{transit} engine; the raw key will be
    marshaled into bytes to be used for the HMAC function. If the key
    is of a type that supports rotation, the latest (current) version
    will be used.
  params:
    name: Specifies the name of the encryption key to generate hmac against
    data: The input data, as a raw vector
    key_version: >-
      Specifies the version of the key to use for the operation. If
      not set, uses the latest version. Must be greater than or equal
      to the key's \code{min_encryption_version}, if set.
    algorithm: >-
      Specifies the hash algorithm to use. Currently-supported
      algorithms are: \code{sha2-224}, \code{sha2-256},
      \code{sha2-384} and \code{sha2-512}.  The default is
      \code{sha2-256}.

sign:
  short: >-
    Returns the cryptographic signature of the given data using the
    named key and the specified hash algorithm. The key must be of a
    type that supports signing.
  params:
    name: Specifies the name of the encryption key to use for signing
    data: The input data, as a raw vector
    hash_algorithm: >-
      Specifies the hash algorithm to use. Currently-supported
      algorithms are: \code{sha2-224}, \code{sha2-256},
      \code{sha2-384} and \code{sha2-512}.  The default is
      \code{sha2-256}.
    prehashed: >-
      Set to true when the input is already hashed. If the key type is
      \code{rsa-2048} or \code{rsa-4096}, then the algorithm used to
      hash the input should be indicated by the \code{hash_algorithm}
      parameter.
    signature_algorithm: >-
      When using a RSA key, specifies the RSA signature algorithm to
      use for signing. Supported signature types are \code{pss} (the
      default) and \code{pkcs1v15}.
    key_version: >-
      Specifies the version of the key to use for signing. If not set,
      uses the latest version. Must be greater than or equal to the
      key's \code{min_encryption_version}, if set,
    context: *context

verify_signature:
  short: >-
    Determine whether the provided signature is valid for the given data.
  params: &verify-params
    name: Name of the key
    data: Data to verify, as a raw vector
    signature: The signed data, as a string.
    hash_algorithm: >-
      Specifies the hash algorithm to use. This can also be specified
      as part of the URL (see \code{$sign} and \code{$hmac} for
      details).
    signature_algorithm: >-
      When using a RSA key, specifies the RSA signature algorithm to
      use for signature verification
    context: *context
    prehashed: Set to \code{TRUE} when the input is already hashed

verify_hmac:
  short: >-
    Determine whether the provided signature is valid for the given data.
  params: *verify-params

key_backup:
  short: >-
    Returns a plaintext backup of a named key. The backup contains all
    the configuration data and keys of all the versions along with the
    HMAC key. The response from this endpoint can be used with
    \code{$key_restore} to restore the key.
  params:
    name: Name of the key to backup

key_restore:
  short: >-
    Restores the backup as a named key. This will restore the key
    configurations and all the versions of the named key along with
    HMAC keys. The input to this method should be the output of
    \code{$key_restore} method.
  params:
    name: Name of the restored key.
    backup: >-
      Backed up key data to be restored. This should be the output
      from the \code{$key_backup} endpoint.
    force: >-
      Logical.  If \code{TRUE}, then force the restore to proceed even
      if a key by this name already exists.

key_trim:
  short: >-
    This endpoint trims older key versions setting a minimum version
    for the keyring. Once trimmed, previous versions of the key cannot
    be recovered.
  params:
    name: Key to trim
    min_version: >-
      The minimum version for the key ring. All versions before this
      version will be permanently deleted. This value can at most be
      equal to the lesser of \code{min_decryption_version} and
      \code{min_encryption_version}. This is not allowed to be set
      when either \code{min_encryption_version} or
      \code{min_decryption_version} is set to zero.
